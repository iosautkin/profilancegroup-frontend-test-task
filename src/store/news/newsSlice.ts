import { createAsyncThunk, createSlice, PayloadAction } from '@reduxjs/toolkit';
import { RootState } from '../index';
import { addNews, approveNews, fetchNews, removeNews } from './newsAPI';



export interface INew {
  id: number,
  published: boolean,
  title: string,
  text: string,
  createdAt: string,
}

export interface NewsState {
  news: INew[];
  status: 'idle' | 'loading' | 'failed';
}

const initialState: NewsState = {
  news: [],
  status: 'idle',
};

export const loadNews = createAsyncThunk(
  'news/fetchNews',
  async (search: string) => {
    const response = await fetchNews(search);
    return response.data;
  }
);


export const createNews = createAsyncThunk(
  'news/createNews',
  async ({ title, text }: { title: string, text: string }, { getState }) => {
    const newsItem = {
      id: Math.round(Math.random()*10**10),
      published: false,
      title,
      text,
      createdAt: `${new Date()}`,
    };
    const response = await addNews(newsItem);
    return { response, newsItem };
  }
);


export const publishNews = createAsyncThunk(
  'news/publishNews',
  async (id: number, { getState }) => {
    const response = await approveNews(id);
    return response;
  }
);

export const deleteNews = createAsyncThunk(
  'news/deleteNews',
  async (id: number, { getState }) => {
    const response = await removeNews(id);
    return { response, id };
  }
);

export const newsSlice = createSlice({
  name: 'news',
  initialState,
  reducers: {
    increment: (state) => {
      state.news = [];
    },
    incrementByAmount: (state, action: PayloadAction<number>) => {
      state.news = [];
    },
  },
  // The `extraReducers` field lets the slice handle actions defined elsewhere,
  // including actions generated by createAsyncThunk or in other slices.
  extraReducers: (builder) => {
    builder
      .addCase(loadNews.pending, (state) => {
        state.status = 'loading';
      })
      .addCase(loadNews.fulfilled, (state, action) => {
        state.status = 'idle';
        state.news = action.payload;
      })
      .addCase(createNews.pending, (state) => {
        state.status = 'loading';
      })
      .addCase(createNews.fulfilled, (state, action) => {
        state.status = 'idle';
        state.news.unshift(action.payload.newsItem);
      })
      .addCase(publishNews.pending, (state) => {
        state.status = 'loading';
      })
      .addCase(publishNews.fulfilled, (state, action) => {
        state.status = 'idle';
        const newsItem = state.news.find(n => n.id ===  action.payload.id);
        if (newsItem) newsItem.published = true;
      })
      .addCase(deleteNews.pending, (state) => {
        state.status = 'loading';
      })
      .addCase(deleteNews.fulfilled, (state, action) => {
        state.status = 'idle';
        state.news = state.news.filter(n => n.id !== action.payload.id);
      });
  },
});

export const { increment, incrementByAmount } = newsSlice.actions;

// вообще, конечно, фильтрацию стоит делать на бекенде,
// чтобы было невозможно программно получить доступ к недоступной инфомации
export const selectAvailableNews = (state: RootState) => {
  const role = state.auth.user?.role;
  if (role === 'admin') return state.news.news;
  return state.news.news.filter(n => n.published);
}

export default newsSlice.reducer;
 